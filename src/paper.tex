\documentclass{article}
\setlength{\parindent}{0pt}
\setlength{\parskip}{1em}
\usepackage{unicode-math}
\usepackage{lualatex-math}
\setmathfont{STIX Two Math}

\usepackage{biblatex}
\addbibresource{references.bib}

\usepackage{xcolor}
\usepackage{amsmath}
%\usepackage{amssymb}
\usepackage{listings}

\DeclareMathOperator{\acc}{value}

\usepackage{mathtools}
\usepackage{tikz}
\usetikzlibrary{automata, trees, positioning, arrows, fit, matrix, shapes.geometric, shapes.misc, calc}
\pgfdeclarelayer{background}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,main,foreground}

\newcommand{\Ex}{\textbf{Npr.:}\ }
\newcommand{\Special}[1]{\textbf{#1}}
\newcommand{\FIRST}{\textsc{first}}
\newcommand{\OK}{\ \checkmark}
\newcommand{\FOLLOW}{\textsc{follow}}
\newcommand{\EOF}{\textsc{eof}}
\newcommand{\Set}[1]{\mathbf{#1}}
\newcommand{\Symbol}[1]{\textcolor{blue}{#1}}
\newcommand{\Grammar}{G}
\newcommand{\Terminals}{\Set{T}}
\newcommand{\NonTerminals}{\Set{N}}
\newcommand{\Productions}{\Set{P}}
\newcommand{\StartSymbol}{S}
\newcommand{\Empty}{\varnothing}
\newcommand{\Null}{\varepsilon}
\newcommand{\Language}[1]{\mathcal{L}(#1)}
\newcommand{\Automaton}[1]{\mathcal{M}(#1)}
\newcommand{\Powerset}[1]{\mathcal{P}(#1)}
\newcommand{\Str}[1]{\text{\textquotedbl\texttt{#1}\textquotedbl}}
\newcommand{\Char}[1]{\texttt{#1}}
\newcommand{\MathRef}[1]{\text{\ref{#1}}}
\newcommand{\Arrow}{\Coloneq}
\newcommand{\Derive}{\Rightarrow}
\newcommand{\DeriveStar}{\overset{\ast}{\Rightarrow}}
\newcommand{\DerivePlus}{\overset{+}{\Rightarrow}}
\newcommand{\Seq}{\ }
\newcommand{\Union}{\mathrel{|}}
\newcommand{\Kleene}[1]{#1^\ast}
\newcommand{\Rep}[2]{#1^#2}
\newcommand{\Opt}[1]{#1?}
\newcommand{\KleenePlus}[1]{#1^+}
\newcommand{\Lookahead}[1]{{}_{\{{#1}\}}}
\newcommand{\Lk}[1]{{}_{{#1}}}

\newcounter{ngrammar}
\setcounter{ngrammar}{0}
\newcommand{\NGrammar}{\tag{$\Grammar_{\arabic{ngrammar}}$}\stepcounter{ngrammar}}

\lstnewenvironment{algorithm}[1][]
{   
    \lstset{
        mathescape=true,
        %frame=tB,
        numbers=left, 
        %numberstyle=\tiny,
        basicstyle=\footnotesize, 
        %keywordstyle=\color{black}\bfseries\em,
        keywords={,input, output, return, datatype, function, in, if, else, foreach, while, begin, end, when, true, false, switch, case, default, } 
        numbers=left,
        xleftmargin=.04\textwidth,
        #1
    }
}
{}

\begin{document}
%\Special{Meta:} Simboli so omejeni na (pod)poglavja.
\Special{Meta:} Konkretni simboli so obarvani z modro $\Symbol{A}$, spremenljivke pa z črno $A$, množice $\Set{S}$ so označene s krepko pisavo.
Neterminalni simboli so zapisani z velikimi črkami iz začetka latinske abecede $A$, terminalni simboli so zapisani z malimi črkami iz začetka latinske abecede $a$, neterminalni ali terminalni simboli so zapisani z velikimi črkami iz konca latinske abecede $X$, seznami neterminalnih ali terminalnih simbolov so zapisani z mali črkami iz začetka grške abecede $\alpha$ in seznami terminalnih simbolov so zapisani z malimi črkami iz konca latinske abecede $w$.

\Special{Ponovitev:}
Konkatenacija množic je podobna kartezičnemu produktu (vsakega z vsakim).
\begin{align*}
  S &= P \times Q \\
  S &= \{ (x, y) \mid x \in P \land y \in Q\}
\end{align*}
\Ex
\begin{align*}
  P &= \{1, 2, 3\}\\
  Q &= \{a, b\}\\
  S &= \{(1, a), (1, b), (2, a), (2, b), (3, a), (3, b) \}
\end{align*}

Edina razlika je da zamenjamo vsak $(u, v)$, kjer $u \in U$ in $v\in V$, z $u \Seq v \in W$.
\begin{equation*}
  W = \{ u \Seq v \mid u \in U \land v \in V\}
\end{equation*}

\Ex
\begin{align*}
  U &= \{\Symbol{a}, \Symbol{b}, \Symbol{c}\}\\
  V &= \{\Symbol{e}, \Symbol{f}\}\\
  W &= \{\Symbol{a} \Seq \Symbol{e}, \Symbol{a} \Seq \Symbol{f}, \Symbol{b} \Seq \Symbol{e}, \Symbol{b} \Seq \Symbol{f}, \Symbol{c} \Seq \Symbol{e}, \Symbol{c} \Seq \Symbol{f}\}
\end{align*}

\section{Gramatike}
Gramatika je tuple $\Grammar = (\NonTerminals, \Terminals, \Productions, \StartSymbol)$, kjer je $\NonTerminals$ končna množica neterminalnih simbolov, $\Terminals$ končna množica terminalnih simbolov, $\Productions$ je končna relacija produkcij $\NonTerminals \times \Kleene{(\NonTerminals \cup \Terminals)}$ in $\StartSymbol \in \NonTerminals$ je začetni simbol.
Tukaj $\Kleene{(\NonTerminals \cup \Terminals)}$ pomeni seznam terminalnih in neterminalnih simbolov (prazen seznam je $\Null$).

\Ex
\begin{align*}
  \Grammar_1 &= (\NonTerminals_1, \Terminals_1, \Productions_1, \StartSymbol_1) \\
  \NonTerminals_1 &= \{\Symbol{L}\}\\
  \Terminals_1 &= \{\Symbol{i}\}\\
  \Productions_1 &= \{ (\Symbol{L}, (\Symbol{i}, \Symbol{L})), (\Symbol{L}, \Null) \}\\
  \StartSymbol_1 &= \Symbol{L}
\end{align*}

Produkcijska pravila pišemo z operatorjem $(\Arrow)$, na levi strani je vedno en neterminalen simbol na desni pa je lahko seznam terminalnih in neterminalnih simbolov.

\Special{Meta:} Simbol na levi strani prve produkcije bo začetni simbol.

\Ex
\begin{equation}
  \NGrammar{}
  \label{g:listi}
  \begin{aligned}
    \Symbol{L} &\Arrow \Symbol{i} \Seq \Symbol{L}\\
    \Symbol{L} &\Arrow \Null
  \end{aligned}
\end{equation}

Produkcijska pravila, ki imajo na levi strani enak neterminalen simbol lahko združimo z unijo.

\Ex
\begin{align*}
  \Symbol{L} &\Arrow \Symbol{i} \Seq \Symbol{L} \Union \Null\\
\end{align*}
Gramatike so sistem prepisovanja.
V seznamu terminalnih in neterminalnih simbolov, lahko neterminalne simbole zamenjamo z eno izmed desnih strani produkcijskega pravila, ki ima ta simbol na levi strani.
Postopek je podoben, kot pri vstavljanju v enačbo, le da lahko imamo več različnih možnosti (več desnih strani).

\Ex
  \begin{align*}
    y &= x + x\\
    x &= 1
  \end{align*}
  Če bi imeli poleg tega enačbo $x = 2$, bi nastal problem ($1 = 2$).

  \begin{equation*}
    y = x + x = 1 + x = 1 + 1
  \end{equation*}

  \begin{equation}
    \NGrammar{}
    \label{g:plusab}
    \begin{aligned}
      \Symbol{E} &\Arrow \Symbol{N} \Seq \Symbol{p} \Seq \Symbol{N}\\
      \Symbol{N} &\Arrow \Symbol{a} \Union \Symbol{b}
    \end{aligned}
  \end{equation}

\Special{Meta:} Vedno bomo najprej zamenjali najbolj levi neterminalen simbol. Torej se bomo omejili samo na najbolj levo izpeljavo.

Če smo zamenjali samo en neterminalen simbol potem uporabimo operator $(\Derive)$, če smo jih zamenjali več $(\DerivePlus)$, če smo jih zamenjali več ali nobenega pa $(\DeriveStar)$.
  \begin{align*}
    \Symbol{E} &\Derive \Symbol{N} \Seq \Symbol{p} \Seq \Symbol{N} \Derive \Symbol{a} \Seq \Symbol{p} \Seq \Symbol{N} \Derive \Symbol{a} \Seq \Symbol{p} \Seq \Symbol{b} \\
    \Symbol{E} &\DerivePlus \Symbol{N} \Seq \Symbol{p} \Seq \Symbol{N}\\
    \Symbol{N} \Seq \Symbol{p} \Seq \Symbol{N} &\DerivePlus \Symbol{a} \Seq \Symbol{p} \Seq \Symbol{b}\\
    \Symbol{a} \Seq \Symbol{p} \Seq \Symbol{N} &\DerivePlus \Symbol{a} \Seq \Symbol{p} \Seq \Symbol{b}\\
    \Symbol{E} &\DerivePlus \Symbol{a} \Seq \Symbol{p} \Seq \Symbol{b}\\
    \Symbol{E} &\DeriveStar \Symbol{E}\\
    \Symbol{N} \Seq \Symbol{p} \Seq \Symbol{N} &\DeriveStar \Symbol{N} \Seq \Symbol{p} \Seq \Symbol{N}\\
    \Symbol{E} &\DeriveStar \Symbol{a} \Seq \Symbol{p} \Seq \Symbol{b}
  \end{align*}

Stavčne oblike gramatike, so vsi seznami neterminalnih ali terminalnih simbolov $\alpha \in \Kleene{(\NonTerminals \cup \Terminals)}$, kjer $\StartSymbol \DeriveStar \alpha$.
Seznam vseh stavčnih oblik dobimo tako, da gremo sistematično skozi vse možne izpeljave.

\Ex
  \begin{equation*}
    \Symbol{L} \begin{aligned}[t]
      &\Derive \Symbol{i} \Seq \Symbol{L} \begin{aligned}[t]
        &\Derive \Symbol{i} \Seq \Symbol{i} \Seq \Symbol{L} \begin{aligned}[t]
          &\Derive \Symbol{i} \Seq \Symbol{i} \Seq \Symbol{i} \Seq \Symbol{L} \Derive \dots\\
          &\Derive \Symbol{i} \Seq \Symbol{i} \Seq \Null 
        \end{aligned}\\
        &\Derive \Symbol{i} \Seq \Null 
      \end{aligned}\\
      &\Derive \Null
    \end{aligned}
  \end{equation*}
Za \ref{g:listi} so vse stavčne oblike $\{\Symbol{L}, \Symbol{i} \Seq \Symbol{L}, \Symbol{i} \Seq \Symbol{i} \Seq \Symbol{L}, \dots, \Null, \Symbol{i}, \Symbol{i} \Seq \Symbol{i}, \dots\}$.

  \begin{equation*}
    \Symbol{E} \Derive \Symbol{N} \Seq \Symbol{p} \Seq \Symbol{N} \begin{aligned}[t]
      &\Derive \Symbol{a} \Seq \Symbol{p} \Seq \Symbol{N} \begin{aligned}[t]
        &\Derive \Symbol{a} \Seq \Symbol{p} \Seq \Symbol{a}\\
        &\Derive \Symbol{a} \Seq \Symbol{p} \Seq \Symbol{b}\\
      \end{aligned}\\
      &\Derive \Symbol{b} \Seq \Symbol{p} \Seq \Symbol{N} \begin{aligned}[t]
        &\Derive \Symbol{b} \Seq \Symbol{p} \Seq \Symbol{a}\\
        &\Derive \Symbol{b} \Seq \Symbol{p} \Seq \Symbol{b}\\
      \end{aligned}
    \end{aligned}
  \end{equation*}
Za \ref{g:plusab} so vse stavčne oblike $\{\Symbol{E}, \Symbol{N} \Seq \Symbol{p} \Seq \Symbol{N}, \Symbol{a} \Seq \Symbol{p} \Seq \Symbol{N}, \Symbol{b} \Seq \Symbol{p} \Seq \Symbol{N}, \Symbol{a} \Seq \Symbol{p} \Seq \Symbol{a}, \Symbol{a} \Seq \Symbol{p} \Seq \Symbol{b}, \Symbol{b} \Seq \Symbol{p} \Seq \Symbol{a}, \Symbol{b} \Seq \Symbol{p} \Seq \Symbol{b} \}$.

Stavki gramatike, so vsi seznami terminalnih simbolov $w \in \Kleene{\Terminals}$, kjer $\StartSymbol \DeriveStar w$.
Seznam vseh stavkov dobimo tako, da gremo sistematično skozi vse možne izpeljave in izberemo samo tiste stavčne oblike, ki vsebujejo samo terminalne simbole.

\Ex
Za \ref{g:listi} so vsi stavki $\{\Null, \Symbol{i}, \Symbol{i} \Seq \Symbol{i}, \dots\}$.

Za \ref{g:plusab} vsi stavki $\{\Symbol{a} \Seq \Symbol{p} \Seq \Symbol{a}, \Symbol{a} \Seq \Symbol{p} \Seq \Symbol{b}, \Symbol{b} \Seq \Symbol{p} \Seq \Symbol{a}, \Symbol{b} \Seq \Symbol{p} \Seq \Symbol{b} \}$.

Jezik, ki ga gramatika opisuje je množica vseh stavkov:
\begin{equation*}
  \Language{\Grammar} = \{ w \in \Kleene{T} \mid \StartSymbol \DeriveStar w\}
\end{equation*}

\Ex
  \begin{align*}
    \Language{\MathRef{g:listi}} &= \{\Null, \Symbol{i}, \Symbol{i} \Seq \Symbol{i}, \dots\}\\
    \Language{\MathRef{g:plusab}} &= \{\Symbol{a} \Seq \Symbol{p} \Seq \Symbol{a}, \Symbol{a} \Seq \Symbol{p} \Seq \Symbol{b}, \Symbol{b} \Seq \Symbol{p} \Seq \Symbol{a}, \Symbol{b} \Seq \Symbol{p} \Seq \Symbol{b} \}
  \end{align*}

\subsection{Razpoznavanje}

Preveriti želimo ali je nek seznam terminalov $u \in \Kleene{T}$ v jeziku za gramatiko $\Grammar$, torej $u \in \Language{\Grammar}$.

\Ex
  \begin{equation*}
    \Symbol{i} \Seq \Symbol{i} \in \Language{\MathRef{g:listi}}
  \end{equation*}

  Ker $\Symbol{i} \Seq \Symbol{i} \in \{\Null, \Symbol{i}, \Symbol{i} \Seq \Symbol{i}, \dots\}$ je odgovor v tem primeru pritrdilen.

Problem je, da moramo iti sistematično skozi vse stavke.

Rešitev je, da poskušamo iz $\StartSymbol$ izpeljati vhoden niz $u$, če je to mogoče potem $\StartSymbol \DeriveStar u$ in $u \in \Language{\Grammar}$ (po definiciji).
Ker vhoden niz $u$ poznamo v naprej, stavčnih oblik iz katerih $u$ ne gre izpeljati ne rabimo upoštevati.

\Ex
Izpeljava $\Symbol{L} \DeriveStar \Symbol{i} \Seq \Symbol{i}$ s poskušanjem:
  \begin{equation*}
    \Symbol{L} \Derive \Symbol{i} \Seq \Symbol{L} \Derive \Symbol{i} \Seq \Symbol{i} \Seq \Symbol{L} \Derive \Symbol{i} \Seq \Symbol{i} \Seq \Null \OK
  \end{equation*}
  \begin{center}
  \begin{tabular}{|c|c|c|}
    \hline
    $\underline{\Symbol{i}} \Seq \Symbol{i}$ & $\underline{\Symbol{L}}$ & $\Symbol{i} \Seq \Symbol{L} \Union \Null$ \\ 
    $\Symbol{i} \Seq \underline{\Symbol{i}}$ & $\Symbol{i} \Seq \underline{\Symbol{L}}$ & $\Symbol{i} \Seq \Symbol{L} \Union \Null$ \\ 
    \hline
    $\Symbol{i} \Seq \Symbol{i}$ & $\Symbol{i} \Seq \Symbol{i} \Seq \Null$  &  \\ 
    \hline
  \end{tabular}
  \end{center}
  Dobimo $\Symbol{i} \Seq \Symbol{i}$, torej je odgovor pritrdilen.

\Ex
  \begin{equation*}
    \Symbol{b} \Seq \Symbol{p} \Seq \Symbol{a} \in \Language{\MathRef{g:plusab}}
  \end{equation*}

Izpeljava $\Symbol{E} \DeriveStar \Symbol{b} \Seq \Symbol{p} \Seq \Symbol{a}$ s poskušanjem:
  \begin{equation*}
    \Symbol{E} \Derive \Symbol{N} \Seq \Symbol{p} \Seq \Symbol{N} \begin{aligned}[t]
      &\Derive \Symbol{a} \Seq \Symbol{p} \Seq \Symbol{N}\\
      &\Derive \Symbol{b} \Seq \Symbol{p} \Seq \Symbol{N} \Derive \Symbol{b} \Seq \Symbol{p} \Seq \Symbol{a} \OK
    \end{aligned}
  \end{equation*}

\begin{center}
\begin{tabular}{|c|c|c|}
  \hline
  $\underline{\Symbol{b}} \Seq \Symbol{p} \Seq \Symbol{a}$ & $\underline{\Symbol{E}}$ & $\Symbol{N} \Seq \Symbol{p} \Seq \Symbol{N}$ \\ 
  $\underline{\Symbol{b}} \Seq \Symbol{p} \Seq \Symbol{a}$ & $\underline{\Symbol{N}} \Seq \Symbol{p} \Seq \Symbol{N}$ & $\Symbol{a} \Union \Symbol{b}$ \\ 
  $\Symbol{b} \Seq \Symbol{p} \Seq \underline{\Symbol{a}}$ & $\Symbol{a} \Seq \Symbol{p} \Seq \underline{\Symbol{N}}$ & $\Symbol{a} \Union \Symbol{b}$ \\ 
  \hline
  $\Symbol{b} \Seq \Symbol{p} \Seq \Symbol{a}$ & $\Symbol{a} \Seq \Symbol{p} \Seq \Symbol{b}$ &  \\ 
  \hline
\end{tabular}
\end{center}

Tukaj imamo dve možnosti ali uporabimo $\Symbol{N} \Arrow \Symbol{a}$ ali pa $\Symbol{N} \Arrow \Symbol{b}$.
Rešitev je, da $\Symbol{a} \Seq \Symbol{p} \Seq \Symbol{N}$ in $\Symbol{b} \Seq \Symbol{p} \Seq \Symbol{N}$ primerjamo s $\Symbol{b} \Seq \Symbol{p} \Seq \Symbol{a}$.
Pravilna izbira je $\Symbol{N} \Arrow \Symbol{b}$.
Nato $\Symbol{b} \Seq \Symbol{p} \Seq \Symbol{a}$ in $\Symbol{b} \Seq \Symbol{p} \Seq \Symbol{b}$ primerjamo s $\Symbol{b} \Seq \Symbol{p} \Seq \Symbol{a}$.
Pravilna izbira je $\Symbol{N} \Arrow \Symbol{a}$.
Dobimo $\Symbol{b} \Seq \Symbol{p} \Seq \Symbol{a}$, torej je odgovor priterdilen.

\Ex
V primeru, da imamo naslednjo gramatiko pa izbira ni takoj jasna:
\begin{equation*}
  \NGrammar{}
  \label{g:first}
  \begin{aligned}
    \Symbol{S} &\Arrow \Symbol{A} \Seq \Symbol{C} \Union \Symbol{B} \Seq \Symbol{f} \\
    \Symbol{A} &\Arrow \Symbol{D} \Union \Symbol{a} \Seq \Symbol{B} \\
    \Symbol{B} &\Arrow \Symbol{b}\\
    \Symbol{C} &\Arrow \Symbol{c} \Seq \Symbol{d}\\
    \Symbol{D} &\Arrow \Symbol{e} \Union \Null
  \end{aligned}
\end{equation*}

\begin{equation*}
  \Symbol{e} \Seq \Symbol{c} \Seq \Symbol{d} \in \Language{\MathRef{g:first}}
\end{equation*}

Izpeljava $\Symbol{S} \DeriveStar \Symbol{e} \Seq \Symbol{c} \Seq \Symbol{d}$ s poskušanjem:
\begin{equation*}
  \Symbol{S} \begin{aligned}[t]
    &\Derive \Symbol{A} \Seq \Symbol{C} \begin{aligned}[t]
      &\Derive \Symbol{D} \Seq \Symbol{C} \begin{aligned}[t]
        &\Derive \Symbol{e} \Seq \Symbol{C} \Derive \Symbol{e} \Seq \Symbol{c} \Seq \Symbol{d} \OK\\
        &\Derive \Null \Seq \Symbol{C} \Derive \Symbol{c} \Seq \Symbol{d}
      \end{aligned}\\
      &\Derive \Symbol{a} \Seq \Symbol{B} \Seq \Symbol{C}
    \end{aligned}\\
    &\Derive \Symbol{B} \Seq \Symbol{f} \Derive \Symbol{b} \Seq \Symbol{f}
  \end{aligned}
\end{equation*}

Izbrati je potrebno tisto desno stran iz katere je mogoče izpeljati $\Symbol{e} \Seq \Symbol{c} \Seq \Symbol{d}$.
Torej zanima nas ali $\Symbol{A} \Seq \Symbol{C} \DeriveStar \Symbol{e} \Seq \Symbol{c} \Seq \Symbol{d}$ ali $\Symbol{B} \Seq \Symbol{f} \DeriveStar \Symbol{e} \Seq \Symbol{c} \Seq \Symbol{d}$.
\begin{center}
\begin{tabular}{|c|c|c|}
  \hline
  $\underline{\Symbol{e}} \Seq \Symbol{c} \Seq \Symbol{d}$ & $\underline{\Symbol{S}}$ & $\Symbol{A} \Seq \Symbol{C} \Union \Symbol{B} \Seq \Symbol{f}$ \\ 
  \hline
\end{tabular}
\end{center}
Sicer bi lahko to preverili s poizkušanjem:
\begin{equation*}
  \begin{aligned}[t]
    &\Symbol{A} \Seq \Symbol{C} \begin{aligned}[t]
      &\Derive \Symbol{D} \Seq \Symbol{C} \begin{aligned}[t]
        &\Derive \Symbol{e} \Seq \Symbol{C} \Derive \Symbol{e} \Seq \Symbol{c} \Seq \Symbol{d} \OK\\
        &\Derive \Null \Seq \Symbol{C} \Derive \Symbol{c} \Seq \Symbol{d}
      \end{aligned}\\
      &\Derive \Symbol{a} \Seq \Symbol{B} \Seq \Symbol{C}
    \end{aligned}\\
    &\Symbol{B} \Seq \Symbol{f} \Derive \Symbol{b} \Seq \Symbol{f}
  \end{aligned}
\end{equation*}
Ampak, kot opazimo je skoraj enako dela, kot če poskušamo izpeljati $\Symbol{S} \DeriveStar \Symbol{e} \Seq \Symbol{c} \Seq \Symbol{d}$.
Namesto tega, kot poenostavitev, izbiramo samo glede na prvi terminalni simbol.
Torej zanima nas ali $\Symbol{A} \Seq \Symbol{C} \DeriveStar \Symbol{e} \Seq \beta$ ali $\Symbol{B} \Seq \Symbol{f} \DeriveStar \Symbol{e} \Seq \beta$.
Prednost tega pristopa je, da lahko vse terminalne simbole s katerimi se začneta $\Symbol{A} \Seq \Symbol{C}$ in $\Symbol{B} \Seq \Symbol{f}$ izračunamo v naprej.
Enako lahko storimo za ostale desne strani produkcij.
Temu rečemo $\FIRST$:
\begin{equation*}
  \begin{aligned}
    \Symbol{S} &\Arrow \Lk{\FIRST(\Symbol{A} \Seq \Symbol{C})} \Symbol{A} \Seq \Symbol{C} \Union \Lk{\FIRST(\Symbol{B} \Seq \Symbol{f})} \Symbol{B} \Seq \Symbol{f} \\
    \Symbol{A} &\Arrow \Lk{\FIRST(\Symbol{D})} \Symbol{D} \Union \Lk{\FIRST(\Symbol{a} \Seq \Symbol{B})} \Symbol{a} \Seq \Symbol{B} \\
    \Symbol{B} &\Arrow \Symbol{b}\\
    \Symbol{C} &\Arrow \Symbol{c} \Seq \Symbol{d}\\
    \Symbol{D} &\Arrow \Lk{\FIRST(\Symbol{e})} \Symbol{e} \Union \Lk{\FIRST(\Null)} \Null
  \end{aligned}
\end{equation*}
V tem primeru, konkretno:
\begin{equation*}
  \begin{aligned}
    \Symbol{S} &\Arrow \Lookahead{\Symbol{a}, \Symbol{c}, \Symbol{e}} \Symbol{A} \Seq \Symbol{C} \Union \Lookahead{\Symbol{b}} \Symbol{B} \Seq \Symbol{f} \\
    \Symbol{A} &\Arrow \Lookahead{\Symbol{e}, \Null} \Symbol{D} \Union \Lookahead{\Symbol{a}} \Symbol{a} \Seq \Symbol{B} \\
    \Symbol{B} &\Arrow \Symbol{b}\\
    \Symbol{C} &\Arrow \Symbol{c} \Seq \Symbol{d}\\
    \Symbol{D} &\Arrow \Lookahead{\Symbol{e}} \Symbol{e} \Union \Lookahead{\Null} \Null
  \end{aligned}
\end{equation*}
Za produkcije, ki imajo samo eno desno stran $\FIRST$ ne potrebujemo, saj je na voljo samo ena opcija in ne rabimo izbirati.

Desno stran produkcije izberemo glede na prvi terminalen simbol.
Torej, če $\Symbol{e} \in \FIRST(\Symbol{A} \Seq \Symbol{C})$ izberemo $\Symbol{A} \Seq \Symbol{C}$, če $\Symbol{e} \in \FIRST(\Symbol{B} \Seq \Symbol{f})$ izberemo $\Symbol{B} \Seq \Symbol{f}$.
\begin{center}
\begin{tabular}{|c|c|c|}
  \hline
  $\underline{\Symbol{e}} \Seq \Symbol{c} \Seq \Symbol{d}$ & $\underline{\Symbol{S}}$ & $\Lookahead{\Symbol{a}, \Symbol{c}, \underline{\Symbol{e}}} \Symbol{A} \Seq \Symbol{C} \Union \Lookahead{\Symbol{b}} \Symbol{B} \Seq \Symbol{f}$ \\ 
  $\underline{\Symbol{e}} \Seq \Symbol{c} \Seq \Symbol{d}$ & $\underline{\Symbol{A}} \Seq \Symbol{C}$ & $\Lookahead{\underline{\Symbol{e}}, \Null} \Symbol{D} \Union \Lookahead{\Symbol{a}} \Symbol{a} \Seq \Symbol{B}$ \\ 
  $\underline{\Symbol{e}} \Seq \Symbol{c} \Seq \Symbol{d}$ & $\underline{\Symbol{D}} \Seq \Symbol{C}$ & $\Lookahead{\underline{\Symbol{e}}} \Symbol{e} \Union \Lookahead{\Null} \Null$ \\ 
  $\Symbol{e} \Seq \underline{\Symbol{c}} \Seq \Symbol{d}$ & $\Symbol{e} \Seq \underline{\Symbol{C}}$ & $\Symbol{c} \Seq \Symbol{d}$ \\ 
  \hline
  $\Symbol{e} \Seq \Symbol{c} \Seq \Symbol{d}$ & $\Symbol{e} \Seq \Symbol{c} \Seq \Symbol{d}$ & \\ 
  \hline
\end{tabular}
\end{center}
Dobimo $\Symbol{e} \Seq \Symbol{c} \Seq \Symbol{d}$, torej je odgovor pritrdilen.

Opazimo lahko, da določene množice $\FIRST$ vsebujejo $\Null$.
To nam tokrat ni povzročalo težav.
Na težave bi naleteli, na primer, če bi preverjali ali $\Symbol{c} \Seq \Symbol{d} \in \Language{\MathRef{g:first}}$.
Rešitev je, da uporabimo $\FOLLOW$, ki nam pove kaj sledi v primeru kot se desna stran izpelje v $\Null$.
Torej določimo:
\begin{equation*}
  \begin{aligned}
    \Symbol{S} &\Arrow \Lk{\FIRST(\FIRST(\Symbol{A} \Seq \Symbol{C}) \Seq \FOLLOW(\Symbol{S}))} \Symbol{A} \Seq \Symbol{C} \Union \Lk{\FIRST(\FIRST(\Symbol{B} \Seq \Symbol{f}) \Seq \FOLLOW(\Symbol{S}))} \Symbol{B} \Seq \Symbol{f} \\
    \Symbol{A} &\Arrow \Lk{\FIRST(\FIRST(\Symbol{D}) \Seq \FOLLOW(\Symbol{A}))} \Symbol{D} \Union \Lk{\FIRST(\FIRST(\Symbol{a} \Seq \Symbol{B}) \Seq \FOLLOW(\Symbol{A}))} \Symbol{a} \Seq \Symbol{B} \\
    \Symbol{B} &\Arrow \Symbol{b}\\
    \Symbol{C} &\Arrow \Symbol{c} \Seq \Symbol{d}\\
    \Symbol{D} &\Arrow \Lk{\FIRST(\FIRST(\Symbol{e}) \Seq \FOLLOW(\Symbol{D}))} \Symbol{e} \Union \Lk{\FIRST(\FIRST(\Null) \Seq \FOLLOW(\Symbol{D}))} \Null
  \end{aligned}
\end{equation*}
V tem primeru, konkretno:
\begin{equation*}
  \begin{aligned}
    \Symbol{S} &\Arrow \Lookahead{\Symbol{a}, \Symbol{c}, \Symbol{e}} \Symbol{A} \Seq \Symbol{C} \Union \Lookahead{\Symbol{b}} \Symbol{B} \Seq \Symbol{f} \\
    \Symbol{A} &\Arrow \Lookahead{\Symbol{e}, \Symbol{c}} \Symbol{D} \Union \Lookahead{\Symbol{a}} \Symbol{a} \Seq \Symbol{B} \\
    \Symbol{B} &\Arrow \Symbol{b}\\
    \Symbol{C} &\Arrow \Symbol{c} \Seq \Symbol{d}\\
    \Symbol{D} &\Arrow \Lookahead{\Symbol{e}} \Symbol{e} \Union \Lookahead{\Symbol{c}} \Null
  \end{aligned}
\end{equation*}
Opazimo lahko, da v primerih, ko se desna stran ne more izpeljati v $\Null$ (torej, kot $\FIRST$ ne vsebuje $\Null$) dobimo enako, kot če bi uporabili samo $\FIRST$.
Prav tako je pomembno, da so za vsako produkcijo te množice tuje.
Če imamo isti terminalni simbol v več množicah ne bomo mogli enoumno izbrati desne strani.

Ko uporabimo $\FIRST$ in $\FOLLOW$ lahko brez težav razpoznamo tudi $\Symbol{c} \Seq \Symbol{d}$:
\begin{center}
\begin{tabular}{|c|c|c|}
  \hline
  $\underline{\Symbol{c}} \Seq \Symbol{d}$ & $\underline{\Symbol{S}}$ & $\Lookahead{\Symbol{a}, \underline{\Symbol{c}}, \Symbol{e}} \Symbol{A} \Seq \Symbol{C} \Union \Lookahead{\Symbol{b}} \Symbol{B} \Seq \Symbol{f}$ \\ 
  $\underline{\Symbol{c}} \Seq \Symbol{d}$ & $\underline{\Symbol{A}} \Seq \Symbol{C}$ & $\Lookahead{\Symbol{e}, \underline{\Symbol{c}}} \Symbol{D} \Union \Lookahead{\Symbol{a}} \Symbol{a} \Seq \Symbol{B}$ \\ 
  $\underline{\Symbol{c}} \Seq \Symbol{d}$ & $\underline{\Symbol{D}} \Seq \Symbol{C}$ & $\Lookahead{\Symbol{e}} \Symbol{e} \Union \Lookahead{\underline{\Symbol{c}}} \Null$ \\ 
  $\underline{\Symbol{c}} \Seq \Symbol{d}$ & $\Null \Seq \underline{\Symbol{C}}$ & $\Symbol{c} \Seq \Symbol{d}$ \\ 
  \hline
  $\Symbol{c} \Seq \Symbol{d}$ & $\Symbol{c} \Seq \Symbol{d}$ & \\ 
  \hline
\end{tabular}
\end{center}

\section{FIRST}

Funkcija $\FIRST$ vrne množico prvih terminalnih simbolov.
Na splošno je definirana za seznam neterminalnih in terminalnih simbolov:
\begin{equation*}
  \FIRST(\alpha) = \{ a \mid \alpha \DeriveStar a \Seq \beta \} \text{, kjer } \alpha \in \Kleene{(\NonTerminals \cup \Terminals)} \text{ in } a \in \Terminals \text{ in } \beta \in \Kleene{(\NonTerminals \cup \Terminals)}
\end{equation*}

Torej začnemo z $\alpha$ in sistematično zamenjujemo prvi neterminalen simbol z desnimi stranmi, dokler ni na začetku terminalen simbol.

\Ex
\begin{equation*}
  \begin{aligned}
    \Symbol{S} &\Arrow \Symbol{A} \Seq \Symbol{C} \Union \Symbol{B} \Seq \Symbol{f} \\
    \Symbol{A} &\Arrow \Symbol{D} \Union \Symbol{a} \Seq \Symbol{B} \\
    \Symbol{B} &\Arrow \Symbol{b}\\
    \Symbol{C} &\Arrow \Symbol{c} \Seq \Symbol{d}\\
    \Symbol{D} &\Arrow \Symbol{e} \Union \Null
  \end{aligned}
\end{equation*}

\begin{equation*}
  \Symbol{A} \Seq \Symbol{C} \begin{aligned}[t]
    &\Derive \Symbol{D} \Seq \Symbol{C} \begin{aligned}[t]
      &\Derive \Symbol{e} \Seq \Symbol{C} \Derive \underline{\Symbol{e}} \Seq \Symbol{C} \\
      &\Derive \Null \Seq \Symbol{C} \Derive \underline{\Symbol{c}} \Seq \Symbol{d} \\
    \end{aligned}\\
    &\Derive \underline{\Symbol{a}} \Seq \Symbol{B} \Seq \Symbol{C}
  \end{aligned}
\end{equation*}

Prvi terminalni simboli so torej $\Symbol{a}$, $\Symbol{c}$ in $\Symbol{e}$:
\begin{equation*}
  \FIRST(\Symbol{A} \Seq \Symbol{C}) = \{\Symbol{a}, \Symbol{c}, \Symbol{e}\}
\end{equation*}

\Special{Poseben primer:} Če je $\alpha$ enak $\Null$ ${(\alpha = \Null)}$, potem je $\FIRST$ $\Null$:
\begin{equation*}
  \FIRST(\Null) = \{ \Null \}
\end{equation*}

\Special{Poseben primer:} Če je $\alpha$ sestavljen iz samo enega terminalnega simbola ${(\alpha = a)}$, potem je $\FIRST$ ta terminalen simbol, ker trivialno $a \DeriveStar a$.
\begin{equation*}
  \FIRST(a) = \{ a \}
\end{equation*}

\Special{Poseben primer:} Če je $\alpha$ sestavljen iz samo enega neterminalnega simbola ${(\alpha = A)}$, potem je funkcija $\FIRST$:
\begin{equation*}
  \FIRST(A) = \{ a \mid A \DeriveStar a \Seq \beta \}
\end{equation*}
Če imamo produkcijo $A \Arrow \gamma \Union \dots \Union \eta$, potem:
\begin{equation*}
  \FIRST(A) = \FIRST(\gamma) \cup \dots \cup \FIRST(\eta)
\end{equation*}
Ko iščemo $\FIRST(A)$, po splošni definiciji $A$ sistematično zamenjamo z desnimi desnimi stranmi $\gamma, \dots, \eta$ in postopek izvedemo za vsako desno stran, torej poiščemo $\FIRST(\gamma), \dots, \FIRST(\eta)$ in jih nato združimo.

\Ex
Če uporabimo splošno definicijo lahko $\FIRST(\Symbol{S})$ izračunamo tako:
\begin{equation*}
  S \begin{aligned}[t]
    &\Derive \Symbol{A} \Seq \Symbol{C} \begin{aligned}[t]
      &\Derive \Symbol{D} \Seq \Symbol{C} \begin{aligned}[t]
        &\Derive \Symbol{e} \Seq \Symbol{C} \Derive \underline{\Symbol{e}} \Seq \Symbol{C} \\
        &\Derive \Null \Seq \Symbol{C} \Derive \underline{\Symbol{c}} \Seq \Symbol{d} \\
      \end{aligned}\\
      &\Derive \underline{\Symbol{a}} \Seq \Symbol{B} \Seq \Symbol{C}
    \end{aligned}\\
    &\Derive \Symbol{B} \Seq \Symbol{f} \Derive \underline{\Symbol{b}} \Seq \Symbol{f}
  \end{aligned}
\end{equation*}
\begin{equation*}
  \FIRST(\Symbol{S}) = \{\Symbol{a}, \Symbol{b}, \Symbol{c}, \Symbol{e}\}
\end{equation*}

Lahko pa $\FIRST(\Symbol{S})$, razbijemo na $\FIRST(\Symbol{A} \Seq \Symbol{C})$ in $\FIRST(\Symbol{B} \Seq \Symbol{f})$, ker $\Symbol{S} \Arrow \Symbol{A} \Seq \Symbol{C} \Union \Symbol{B} \Seq \Symbol{f}$, izračunamo vsakega posamezno in ju združimo:
\begin{equation*}
  \FIRST(\Symbol{S}) = \FIRST(\Symbol{A} \Seq \Symbol{C}) \cup \FIRST(\Symbol{B})
\end{equation*}
$\FIRST(\Symbol{A} \Seq \Symbol{C})$, smo izračunali že zgoraj:
\begin{equation*}
  \FIRST(\Symbol{A} \Seq \Symbol{C}) = \{\Symbol{a}, \Symbol{c}, \Symbol{e}\}
\end{equation*}

Izračunamo še $\FIRST(\Symbol{B} \Seq \Symbol{f})$ :
\begin{equation*}
  \Symbol{B} \Seq \Symbol{f} \Derive \underline{\Symbol{b}} \Seq \Symbol{f}
\end{equation*}
\begin{equation*}
  \FIRST(\Symbol{B} \Seq \Symbol{f}) = \{\Symbol{b}\}
\end{equation*}

Obe množici nato združimo in dobimo $\FIRST(\Symbol{S})$:
\begin{align*}
  \FIRST(\Symbol{S}) &= \{\Symbol{a}, \Symbol{c}, \Symbol{e}\} \cup \{\Symbol{b}\}\\
  \FIRST(\Symbol{S}) &= \{\Symbol{a}, \Symbol{b}, \Symbol{c}, \Symbol{e}\}
\end{align*}

Definicijo lahko razširimo na množico seznamov neterminalnih in terminalnih simbolov:
\begin{equation*}
  \FIRST(\Set{A}) = \bigcup_{\alpha \in \Set{A}} \FIRST(\alpha) \text{, kjer } \Set{A} \in \Powerset{\Kleene{(\NonTerminals \cup \Terminals)}} \text{ in } \alpha \in \Kleene{(\NonTerminals \cup \Terminals)}
\end{equation*}
Torej izračunamo $\FIRST$ za vsak seznam v $\Set{A}$ in jih združimo.

Lahko se ustavimo na katerem koli koraku izpeljave $\alpha \DeriveStar \gamma$ izračunamo vsak $\FIRST(\gamma)$ posebej in jih združimo:
\begin{equation*}
  \FIRST(\alpha) = \FIRST(\{\gamma \mid \alpha \DeriveStar \gamma\}) = \bigcup_{\alpha \DeriveStar \gamma} \FIRST(\gamma)
\end{equation*}

\Ex
  Iz $\Symbol{S}$ lahko izpeljemo $\Symbol{A} \Seq \Symbol{C}$ in $\Symbol{B} \Seq \Symbol{f}$, in nato izračunamo $\FIRST$ za vsakega posebej.
  \begin{align*}
    \Symbol{S} &\Derive \Symbol{A} \Seq \Symbol{C}\\
    \Symbol{S} &\Derive \Symbol{B} \Seq \Symbol{f}
  \end{align*}
  \begin{align*}
    \FIRST(\Symbol{S}) &= \FIRST(\{\Symbol{A} \Seq \Symbol{C}, \Symbol{B} \Seq \Symbol{f}\}) \\
              &= \FIRST(\Symbol{A} \Seq \Symbol{C}) \cup \FIRST(\Symbol{B} \Seq \Symbol{f})\\
              &= \{\Symbol{a}, \Symbol{c}, \Symbol{e}\} \cup \{\Symbol{b}\} \\
              &= \{\Symbol{a}, \Symbol{b}, \Symbol{c}, \Symbol{e}\}
  \end{align*}
  Lahko vidimo, da je razširitev konsistentna z definicijo za produkcijo (oz. neterminalen simbol).

  Izpeljavo iz $\Symbol{S}$ lahko nadaljujemo do $\Symbol{D} \Seq \Symbol{C}, \Symbol{a} \Seq \Symbol{B} \Seq \Symbol{C}, \Symbol{B} \Seq \Symbol{f}$ (ustavimo se lahko kjer koli):
  \begin{equation*}
    \Symbol{S} \begin{aligned}[t]
      &\Derive \Symbol{A} \Seq \Symbol{C} \begin{aligned}[t]
        &\Derive \Symbol{D} \Seq \Symbol{C}\\
        &\Derive \Symbol{a} \Seq \Symbol{B} \Seq \Symbol{C}
      \end{aligned}\\
      &\Derive \Symbol{B} \Seq \Symbol{f}
    \end{aligned}
  \end{equation*}
  Nato izračunamo $\FIRST$ posebej za vsak $\Symbol{D} \Seq \Symbol{C}, \Symbol{a} \Seq \Symbol{B} \Seq \Symbol{C}, \Symbol{B} \Seq \Symbol{f}$ in jih združimo:
  \begin{align*}
    \FIRST(\Symbol{S}) &= \FIRST(\{\Symbol{D} \Seq \Symbol{C}, \Symbol{a} \Seq \Symbol{B} \Seq \Symbol{C}, \Symbol{B} \Seq \Symbol{f}\}) \\
              &= \FIRST(\Symbol{D} \Seq \Symbol{C}) \cup \FIRST(\Symbol{a} \Seq \Symbol{B} \Seq \Symbol{C}) \cup \FIRST(\Symbol{B} \Seq \Symbol{f})
  \end{align*}
  $\FIRST(\Symbol{B} \Seq \Symbol{f})$ smo izračunali že zgoraj, $\FIRST(\Symbol{a} \Seq \Symbol{B} \Seq \Symbol{C}) = \{\Symbol{a}\}$.
  Izračunamo še $\FIRST(\Symbol{D} \Seq \Symbol{C})$:
  \begin{equation*}
    \Symbol{D} \Seq \Symbol{C} \begin{aligned}[t]
      &\Derive \Symbol{e} \Seq \Symbol{C} \Derive \underline{\Symbol{e}} \Seq \Symbol{C} \\
      &\Derive \Null \Seq \Symbol{C} \Derive \underline{\Symbol{c}} \Seq \Symbol{d} \\
    \end{aligned}
  \end{equation*}
  \begin{equation*}
    \FIRST(\Symbol{D} \Seq \Symbol{C}) = \{\Symbol{e}, \Symbol{c}\}
  \end{equation*}
  Nato rezultate združimo in dobimo $\FIRST(\Symbol{S})$:
  \begin{align*}
    \FIRST(S) &= \{\Symbol{e}, \Symbol{c}\} \cup \{\Symbol{a}\} \cup \{\Symbol{b}\} \\
              &= \{\Symbol{a}, \Symbol{b}, \Symbol{c}, \Symbol{e}\}
  \end{align*}

Če seznam $\alpha$ razdelimo na glavo $X$ in rep $\gamma$ seznama ${(\alpha = X \Seq \gamma)}$, dobimo pravilo:
\begin{equation*}
  \FIRST(X \Seq \gamma) = \FIRST(\FIRST(X) \Seq \FIRST(\gamma))
\end{equation*}
Pravilo lahko razbijemo glede na vrsto simbola:
\begin{align*}
  \FIRST(A \Seq \gamma) &= \FIRST(\FIRST(A) \Seq \FIRST(\gamma))\\
  \FIRST(a \Seq \gamma) &= \FIRST(\FIRST(a) \Seq \FIRST(\gamma)) = \FIRST(a) = \{a\}
\end{align*}
Torej, če je na začetku seznama terminalen simbol, je prvi terminalen simbol trivialno ta simbol.

V primeru, da $\varepsilon \in \FIRST(A)$, potem so lahko na začetku tudi terminalni simboli iz preostanka seznama $\FIRST(\gamma)$ (tukaj uporabimo pravilo za konkatenacijo množic):
\begin{align*}
  \FIRST(A \Seq \gamma) &= \FIRST(\{X \Seq Y \mid X \in \FIRST(A) \land Y \in \FIRST(\gamma)\})\\
   &= \bigcup_{X \in \FIRST(A) \land Y \in \FIRST(\gamma)} \FIRST(X \Seq Y)
\end{align*}
Torej, ko $X = \Null$ potem imamo na začetku seznama $Y$, ker $X \Seq Y = \Null \Seq Y = Y$.

\Ex
  Ko izpeljujemo iz $\Symbol{D} \Seq \Symbol{C}$, se lahko zgodi, da $\Symbol{D} \Derive \Null$, takrat je na začetku $\Symbol{c}$, ker $\Symbol{C} \Derive \underline{\Symbol{c}} \Seq \Symbol{d}$. 
  \begin{equation*}
    \Symbol{D} \Seq \Symbol{C} \begin{aligned}[t]
      &\Derive \Symbol{e} \Seq \Symbol{C} \Derive \underline{\Symbol{e}} \Seq \Symbol{C} \\
      &\Derive \Null \Seq \Symbol{C} \Derive \underline{\Symbol{c}} \Seq \Symbol{d} \\
    \end{aligned}
  \end{equation*}
  \begin{equation*}
    \FIRST(\Symbol{D} \Seq \Symbol{C}) = \{\Symbol{e}, \Symbol{c}\}
  \end{equation*}

  Enako dobimo če uporabimo pravilo.
  Najprej izračunajmo $\FIRST(\Symbol{D})$ in $\FIRST(\Symbol{C})$:
  \begin{align*}
    \FIRST(\Symbol{D}) &= \FIRST(\Symbol{e}) \cup \FIRST(\Null) = \{\Symbol{e}, \Null\}\\
    \FIRST(\Symbol{C}) &= \FIRST(\Symbol{c} \Seq \Symbol{d}) = \{\Symbol{c}\}
  \end{align*}
  Nato izračunamo $\FIRST(\Symbol{D} \Seq \Symbol{C})$ in dobimo enako:
  \begin{equation*}
    \begin{aligned}
      \FIRST(\Symbol{D} \Seq \Symbol{C}) &= \FIRST(\FIRST(\Symbol{D}) \Seq \FIRST(\Symbol{C}))\\
                &= \FIRST(\{\Null, \Symbol{e}\} \Seq \{\Symbol{c}\})\\
                &= \FIRST(\{\Null \Seq \Symbol{c}, \Symbol{e} \Seq \Symbol{c}\})\\
                &= \FIRST(\Null \Seq \Symbol{c}) \cup \FIRST(\Symbol{e} \Seq \Symbol{c})\\
                &= \FIRST(\Symbol{c}) \cup \FIRST(\Symbol{e})\\
                &= \{\Symbol{c}\} \cup \{\Symbol{e}\}\\
                &= \{\Symbol{c}, \Symbol{e}\}
    \end{aligned}
  \end{equation*}
  \begin{equation*}
    \FIRST(\Symbol{D} \Seq \Symbol{C}) = \{\Symbol{e}, \Symbol{c}\}
  \end{equation*}

  Druga interpretacija je:
\begin{equation*}
  \FIRST(A \Seq \gamma) = \begin{cases}
    (\FIRST(A) - \Null) \cup \FIRST(\gamma) & \text{če } A \DeriveStar \Null \\
    \FIRST(A) & \text{sicer} \\
  \end{cases}
\end{equation*}
Obrazložitev je enaka, ko $\Null \in \FIRST(A)$, lahko imamo na začetku terminalne simbole iz $\FIRST(\gamma)$, torej lahko odstranimo $\Null$ iz $\FIRST(A)$ in dodamo terminalne simbole iz $\FIRST(\gamma)$.

\Ex
  $\FIRST(\Symbol{D} \Seq \Symbol{C})$ lahko izračunamo tudi tako (ker $\Symbol{D} \DeriveStar \Null$):
  \begin{equation*}
    \begin{aligned}
      \FIRST(\Symbol{D} \Seq \Symbol{C}) &= (\FIRST(\Symbol{D}) - \Null) \cup \FIRST(\Symbol{C})\\
                &= (\{\Null, \Symbol{e}\} - \Null) \cup \{\Symbol{c}\})\\
                &= \{\Symbol{e}\} \cup \{\Symbol{c}\}\\
                &= \{\Symbol{c}, \Symbol{e}\}
    \end{aligned}
  \end{equation*}

Sedaj imamo dovolj pravil, da gramatiko mehanično pretvorimo v enačbe za $\FIRST$.
Za razpoznavanje potrebujemo $\FIRST$ za desne strani produkcij.
Gramatika ne sme vsebovati leve rekurzije (v tem primeru bi morali poiskati fiksno točko nastale rekurzivne enačbe).
Vrstni red računanja je določen tako: Najprej izračunamo $\FIRST$ za terminalne simbole, nato pa če obstaja produkcija ${B \Arrow \gamma \Seq A \Seq \eta}$, najprej izračunamo $\FIRST$ za vse $A$ in nato izračunamo $\FIRST$ za $B$ (tako optimiziramo ponovno uporabo):

\Ex
\begin{equation*}
  \begin{aligned}
    \Symbol{S} &\Arrow \Symbol{A} \Seq \Symbol{C} \Union \Symbol{B} \Seq \Symbol{f} \\
    \Symbol{A} &\Arrow \Symbol{D} \Union \Symbol{a} \Seq \Symbol{B} \\
    \Symbol{B} &\Arrow \Symbol{b}\\
    \Symbol{C} &\Arrow \Symbol{c} \Seq \Symbol{d}\\
    \Symbol{D} &\Arrow \Symbol{e} \Union \Null
  \end{aligned}
\end{equation*}
Terminalni simboli v tej gramatiki so $\Symbol{a}, \Symbol{b}, \Symbol{c}, \Symbol{d}, \Symbol{e}, \Symbol{f}$, torej:
\begin{align*}
  \FIRST(\Symbol{a}) = \{\Symbol{a}\}\\
  \FIRST(\Symbol{b}) = \{\Symbol{b}\}\\
  \FIRST(\Symbol{c}) = \{\Symbol{c}\}\\
  \FIRST(\Symbol{d}) = \{\Symbol{d}\}\\
  \FIRST(\Symbol{e}) = \{\Symbol{e}\}\\
  \FIRST(\Symbol{f}) = \{\Symbol{f}\}
\end{align*}
Potem izračunamo $\FIRST$ za vse desne strani po omenjenem vrstnem redu:
\begin{align*}
  \FIRST(\Symbol{c} \Seq \Symbol{d}) &= \FIRST(\Symbol{c}) = \{\Symbol{c}\} \\
  \FIRST(\Symbol{C}) &= \FIRST(\Symbol{c} \Seq \Symbol{d}) = \{\Symbol{c}\} \\
  \FIRST(\Symbol{D}) &= \FIRST(\Symbol{e}) \cup \FIRST(\Null) \\
            &= \{\Symbol{e}\} \cup \{\Null\} = \{\Symbol{e}, \Null\} \\
  \FIRST(\Symbol{A}) &= \FIRST(\Symbol{D}) \cup \FIRST(\Symbol{a} \Seq \Symbol{B}) \\
            &= \{\Symbol{e}, \Null\} \cup \{\Symbol{a}\} = \{\Null, \Symbol{a}, \Symbol{e}\} \\
  \FIRST(\Symbol{A} \Seq \Symbol{C}) &= \FIRST(\Symbol{A} \Seq \Symbol{C}) \\
            &= \FIRST(\FIRST(\Symbol{A}) \Seq \FIRST(\Symbol{C})) \\
            &= \FIRST(\{\Null, \Symbol{a}, \Symbol{e}\} \Seq \{\Symbol{c}\})\\
            &= \FIRST(\{\Null \Seq \Symbol{c}, \Symbol{a} \Seq \Symbol{c}, \Symbol{e} \Seq \Symbol{c}\})\\
            &= \FIRST(\Null \Seq \Symbol{c}) \cup \FIRST(\Symbol{a} \Seq \Symbol{c}) \cup \FIRST(\Symbol{e} \Seq \Symbol{c}) \\
            &= \FIRST(\Symbol{c}) \cup \FIRST(\Symbol{a}) \cup \FIRST(\Symbol{e}) \\
            &= \{\Symbol{c}\} \cup \{\Symbol{a}\} \cup \{\Symbol{e}\} \\
            &= \{\Symbol{a}, \Symbol{c}, \Symbol{e}\}\\
  \FIRST(\Symbol{A} \Seq \Symbol{C}) &= \FIRST(\Symbol{A} \Seq \Symbol{C}) \\
            &= (\FIRST(\Symbol{A}) - \Null) \cup \FIRST(\Symbol{C}) \\
            &= (\{\Null, \Symbol{a}, \Symbol{e}\} - \Null) \cup \{\Symbol{c}\} \\
            &= \{\Symbol{a}, \Symbol{e}\} \cup \{\Symbol{c}\}\\
            &= \{\Symbol{a}, \Symbol{c}, \Symbol{e}\}\\
  \FIRST(\Symbol{B}) &= \FIRST(\Symbol{b}) = \{\Symbol{b}\} \\
  \FIRST(\Symbol{B} \Seq \Symbol{f}) &= \FIRST(\FIRST(\Symbol{B}) \Seq \FIRST(\Symbol{f})) \\
            &= \FIRST(\{\Symbol{b}\} \Seq \{\Symbol{f}\})\\
            &= \FIRST(\{\Symbol{b} \Seq \Symbol{f}\})\\
            &= \FIRST(\Symbol{b} \Seq \Symbol{f})\\
            &= \FIRST(\Symbol{b})\\
            &= \{\Symbol{b}\}\\
  \FIRST(\Symbol{B} \Seq \Symbol{f}) &= \FIRST(\Symbol{B})\\
            &= \FIRST(\Symbol{b})\\
            &= \{\Symbol{b}\}
\end{align*}

Izračunamo lahko tudi $\FIRST(\Symbol{S})$ vendar, ga za implementacijo razpoznavalnika ne potrebujemo:
\begin{align*}
  \FIRST(\Symbol{S}) &= \FIRST(\Symbol{A} \Seq \Symbol{C}) \cup \FIRST(\Symbol{B}) \\
            &= \{\Symbol{a}, \Symbol{c}, \Symbol{e}\} \cup \{\Symbol{b}\} = \{\Symbol{a}, \Symbol{b}, \Symbol{c}, \Symbol{e}\}
\end{align*}

V vseh primerih dobimo enako, kot z uporabo splošne definicije:
\begin{equation*}
  \underline{\Symbol{c}} \Seq \Symbol{d}
\end{equation*}
\begin{equation*}
  \FIRST(\Symbol{c} \Seq \Symbol{d}) = \{\Symbol{c}\}
\end{equation*}

\begin{equation*}
  \Symbol{C} \Derive \underline{\Symbol{c}} \Seq \Symbol{d}
\end{equation*}
\begin{equation*}
  \FIRST(\Symbol{C}) = \{\Symbol{c}\}
\end{equation*}

\begin{equation*}
  \Symbol{D} \begin{aligned}[t]
    &\Derive \underline{\Null}\\
    &\Derive \underline{\Symbol{e}}\\
  \end{aligned}
\end{equation*}
\begin{equation*}
  \FIRST(\Symbol{D}) = \{\Null, \Symbol{e}\}
\end{equation*}

\begin{equation*}
  \Symbol{A} \begin{aligned}[t]
    &\Derive \Symbol{D} \begin{aligned}[t]
      &\Derive \underline{\Symbol{e}} \\
      &\Derive \underline{\Null}\\
    \end{aligned}\\
    &\Derive \underline{\Symbol{a}} \Seq \Symbol{B}
  \end{aligned}
\end{equation*}
\begin{equation*}
  \FIRST(\Symbol{A}) = \{\Null, \Symbol{a}, \Symbol{e}\}
\end{equation*}

\begin{equation*}
  \Symbol{A} \Seq \Symbol{C} \begin{aligned}[t]
    &\Derive \Symbol{D} \Seq \Symbol{C} \begin{aligned}[t]
      &\Derive \Symbol{e} \Seq \Symbol{C} \Derive \underline{\Symbol{e}} \Seq \Symbol{C} \\
      &\Derive \Null \Seq \Symbol{C} \Derive \underline{\Symbol{c}} \Seq \Symbol{d} \\
    \end{aligned}\\
    &\Derive \underline{\Symbol{a}} \Seq \Symbol{B} \Seq \Symbol{C}
  \end{aligned}
\end{equation*}
\begin{equation*}
  \FIRST(\Symbol{A} \Seq \Symbol{C}) = \{\Symbol{a}, \Symbol{c}, \Symbol{e}\}
\end{equation*}

\begin{equation*}
  \Symbol{B} \Derive \underline{\Symbol{b}}
\end{equation*}
\begin{equation*}
  \FIRST(\Symbol{B}) = \{\Symbol{b}\}
\end{equation*}

\begin{equation*}
  \Symbol{B} \Seq \Symbol{f} \Derive \underline{\Symbol{b}} \Seq \Symbol{f}
\end{equation*}
\begin{equation*}
  \FIRST(\Symbol{B} \Seq \Symbol{f}) = \{\Symbol{b}\}
\end{equation*}

\begin{equation*}
  \Symbol{S} \begin{aligned}[t]
    &\Derive \Symbol{A} \Seq \Symbol{C} \begin{aligned}[t]
      &\Derive \Symbol{D} \Seq \Symbol{C} \begin{aligned}[t]
        &\Derive \Symbol{e} \Seq \Symbol{C} \Derive \underline{\Symbol{e}} \Seq \Symbol{C} \\
        &\Derive \Null \Seq \Symbol{C} \Derive \underline{\Symbol{c}} \Seq \Symbol{d} \\
      \end{aligned}\\
      &\Derive \underline{\Symbol{a}} \Seq \Symbol{B} \Seq \Symbol{C}
    \end{aligned}\\
    &\Derive \Symbol{B} \Seq \Symbol{f} \Derive \underline{\Symbol{b}} \Seq \Symbol{f}
  \end{aligned}
\end{equation*}
\begin{equation*}
  \FIRST(\Symbol{S}) = \{\Symbol{a}, \Symbol{b}, \Symbol{c}, \Symbol{e}\}
\end{equation*}

%\subsection*{Primeri}

\section{FOLLOW}
Funkcija $\FOLLOW$ vrne vse terminalne simbole, ki sledijo nekemu neterminalnemu simbolu v vseh stavčnih oblikah.
Po konvenciji $\FOLLOW(S) = \{\EOF\}$, torej konec vhoda.

\Ex
\begin{equation*}
  \begin{aligned}
    \Symbol{S} &\Arrow \Lookahead{\Symbol{a}, \Symbol{c}, \Symbol{e}} \Symbol{A} \Seq \Symbol{C} \Union \Lookahead{\Symbol{b}} \Symbol{B} \Seq \Symbol{f} \\
    \Symbol{A} &\Arrow \Lookahead{\Symbol{e}, \Null} \Symbol{D} \Union \Lookahead{\Symbol{a}} \Symbol{a} \Seq \Symbol{B} \\
    \Symbol{B} &\Arrow \Symbol{b}\\
    \Symbol{C} &\Arrow \Symbol{c} \Seq \Symbol{d}\\
    \Symbol{D} &\Arrow \Lookahead{\Symbol{e}} \Symbol{e} \Union \Lookahead{\Null} \Null
  \end{aligned}
\end{equation*}

\begin{equation*}
  \Symbol{c} \Seq \Symbol{d} \in \Language{\MathRef{g:first}}
\end{equation*}

Tokrat bomo pred začetkom izpeljave dodali na konec $\EOF$:
\begin{equation*}
  \Symbol{S} \Seq \EOF \begin{aligned}[t]
    &\Derive \Symbol{A} \Seq \Symbol{C} \Seq \EOF \begin{aligned}[t]
      &\Derive \Symbol{D} \Seq \Symbol{C} \Seq \EOF \begin{aligned}[t]
        &\Derive \Symbol{e} \Seq \Symbol{C} \Seq \EOF\\
        &\Derive \Null \Seq \Symbol{C} \Derive \Symbol{c} \Seq \Symbol{d} \Seq \EOF \OK
      \end{aligned}\\
      &\Derive \Symbol{a} \Seq \Symbol{B} \Seq \Symbol{C} \Seq \EOF
    \end{aligned}\\
    &\Derive \Symbol{B} \Seq \Symbol{f} \Seq \EOF \Derive \Symbol{b} \Seq \Symbol{f} \Seq \EOF
  \end{aligned}
\end{equation*}

\begin{center}
\begin{tabular}{|c|c|c|}
  \hline
  $\underline{\Symbol{c}} \Seq \Symbol{d} \Seq \EOF$ & $\underline{\Symbol{S}} \Seq \EOF$ & $\Lookahead{\Symbol{a}, \underline{\Symbol{c}}, \Symbol{e}} \Symbol{A} \Seq \Symbol{C} \Union \Lookahead{\Symbol{b}} \Symbol{B} \Seq \Symbol{f}$ \\ 
  $\underline{\Symbol{c}} \Seq \Symbol{d} \Seq \EOF$ & $\underline{\Symbol{A}} \Seq \Symbol{C} \Seq \EOF$ & $\Lookahead{\Symbol{e}, \Null} \Symbol{D} \Union \Lookahead{\Symbol{a}} \Symbol{a} \Seq \Symbol{B}$ \\ 
  \hline
\end{tabular}
\end{center}
Tukaj naletimo na problem, ker $\Symbol{c} \notin \FIRST(\Symbol{D})$ in $\Symbol{c} \notin \FIRST(\Symbol{a} \Seq \Symbol{B})$.
Ko pogledamo stavčno obliko $\Symbol{A} \Seq \Symbol{C} \Seq \EOF$, vidimo, da v primeru $\Symbol{A} \DeriveStar \varepsilon$ sledi $\Symbol{C} \Seq \EOF$, torej bo na začetku terminalen simbol iz $\FIRST(\Symbol{C} \Seq \EOF)$.
Rešitev je torej, da se odločimo na podlagi simbolov, ki sledijo $\Symbol{A}$, torej $\FOLLOW(\Symbol{A})$.

Trenutna definicija $\FOLLOW$ je odvisna od specifične stavčne oblike.
$\FOLLOW$, bi želeli izračunati v naprej, enako kot $\FIRST$.
Torej mora delovati za poljubno stavčno obliko.
Rešitev problema je, da $\FOLLOW$ izračunamo za vse možne stavčne oblike in rezultate združimo:
\begin{align*}
  \FOLLOW(A) &= \{a \mid S \Seq \EOF \DeriveStar \gamma \Seq A \underline{\Seq \eta \Seq \EOF} \land a \in \FIRST(\eta \Seq \EOF)\}\\
  &= \bigcup_{S \Seq \EOF\ \DeriveStar\ \gamma \Seq A \Seq \eta \Seq \EOF} \FIRST(\eta \Seq \EOF)
\end{align*}

\Ex Izračunali bomo $\FOLLOW(\Symbol{A})$.
Najprej poiščimo vse stavčne oblike:
\begin{equation*}
  \Symbol{S} \Seq \EOF \begin{aligned}[t]
    &\Derive \Symbol{A} \Seq \underline{\Symbol{C} \Seq \EOF} \begin{aligned}[t]
      &\Derive \Symbol{D} \Seq \Symbol{C} \Seq \EOF \begin{aligned}[t]
        &\Derive \Symbol{e} \Seq \Symbol{C} \Seq \EOF \Derive \Symbol{e} \Seq \Symbol{c} \Seq \Symbol{d} \Seq \EOF \\
        &\Derive \Null \Seq \Symbol{C} \Seq \EOF \Derive \Symbol{c} \Seq \Symbol{d} \Seq \EOF \\
      \end{aligned}\\
      &\Derive \Symbol{a} \Seq \Symbol{B} \Seq \Symbol{C} \Seq \EOF \Derive \Symbol{a} \Seq \Symbol{b} \Seq \Symbol{C} \Seq \EOF \Derive \Symbol{a} \Seq \Symbol{b} \Seq \Symbol{c} \Seq \Symbol{d} \Seq \EOF
    \end{aligned}\\
    &\Derive \Symbol{B} \Seq \Symbol{f} \Seq \EOF \Derive \Symbol{b} \Seq \Symbol{f} \Seq \EOF
  \end{aligned}
\end{equation*}

$\Symbol{A}$ se pojavi v samo eni stavčni obliki $\Symbol{A} \Seq \underline{\Symbol{C} \Seq \EOF}$, torej:
\begin{align*}
  \FOLLOW(\Symbol{A}) &= \FIRST(\Symbol{C} \Seq \EOF) \\
             &= \FIRST(\FIRST(\Symbol{C}) \Seq \FIRST(\EOF))\\
             &= \FIRST(\{\Symbol{c}\} \Seq \{\EOF\})\\
             &= \FIRST(\{\Symbol{c} \Seq \EOF\})\\
             &= \FIRST(\Symbol{c} \Seq \EOF) \\
             &= \FIRST(\Symbol{c})\\
             &= \{\Symbol{c}\}
\end{align*}

\Ex Izračunali bomo $\FOLLOW(\Symbol{B})$.
Najprej poiščimo vse stavčne oblike:
\begin{equation*}
  \Symbol{S} \Seq \EOF \begin{aligned}[t]
    &\Derive \Symbol{A} \Seq \Symbol{C} \Seq \EOF \begin{aligned}[t]
      &\Derive \Symbol{D} \Seq \Symbol{C} \Seq \EOF \begin{aligned}[t]
        &\Derive \Symbol{e} \Seq \Symbol{C} \Seq \EOF \Derive \Symbol{e} \Seq \Symbol{c} \Seq \Symbol{d} \Seq \EOF \\
        &\Derive \Null \Seq \Symbol{C} \Seq \EOF \Derive \Symbol{c} \Seq \Symbol{d} \Seq \EOF \\
      \end{aligned}\\
      &\Derive \Symbol{a} \Seq \Symbol{B} \Seq \underline{\Symbol{C} \Seq \EOF} \Derive \Symbol{a} \Seq \Symbol{b} \Seq \Symbol{C} \Seq \EOF \Derive \Symbol{a} \Seq \Symbol{b} \Seq \Symbol{c} \Seq \Symbol{d} \Seq \EOF
    \end{aligned}\\
    &\Derive \Symbol{B} \Seq \underline{\Symbol{f} \Seq \EOF} \Derive \Symbol{b} \Seq \Symbol{f} \Seq \EOF
  \end{aligned}
\end{equation*}

$\Symbol{B}$ se pojavi v dveh stavčni oblikah $\Symbol{a} \Seq \Symbol{B} \Seq \underline{\Symbol{C} \Seq \EOF}$ in $\Symbol{B} \Seq \underline{\Symbol{f} \Seq \EOF}$, torej:
\begin{align*}
  \FOLLOW(\Symbol{A}) &= \FIRST(\Symbol{C} \Seq \EOF) \cup \FIRST(\Symbol{f} \Seq \EOF)\\
             &= \FIRST(\FIRST(\Symbol{C}) \Seq \FIRST(\EOF)) \cup \FIRST(\Symbol{f} \Seq \EOF)\\
             &= \FIRST(\{\Symbol{c}\} \Seq \{\EOF\}) \cup \FIRST(\Symbol{f} \Seq \EOF)\\
             &= \FIRST(\{\Symbol{c} \Seq \EOF\}) \cup \FIRST(\Symbol{f} \Seq \EOF)\\
             &= \FIRST(\Symbol{c} \Seq \EOF) \cup \FIRST(\Symbol{f} \Seq \EOF)\\
             &= \FIRST(\Symbol{c}) \cup \FIRST(\Symbol{f})\\
             &= \{\Symbol{c}\} \cup \{\Symbol{f}\}\\
             &= \{\Symbol{c}, \Symbol{f}\}
\end{align*}

$\FOLLOW$ lahko določimo tudi na podlagi produkcij:
\begin{align*}
  \FOLLOW(A) &= \bigcup_{B \Arrow \gamma \Seq A \Seq \underline{\eta}\ \in\ \Productions} \FIRST(\FIRST(\underline{\eta}) \Seq \FOLLOW(B))
\end{align*}
O smiselnosti tej definicije se lahko prepričamo tako:
Recimo, da imamo dve produkciji $S \Arrow \sigma \Seq B \Seq \tau$ in $B \Arrow \gamma \Seq A \Seq \eta$.
Potem lahko iz $S \Seq \EOF$ izpeljemo:
\begin{equation*}
  S \Seq \EOF \Derive \sigma \Seq B \Seq \tau \Seq \EOF \Derive \sigma \Seq \gamma \Seq A \Seq \underline{\eta \Seq \tau \Seq \EOF}
\end{equation*}
Torej $S$ sledi $\EOF$, $B$ sledi $\tau \Seq \EOF$, torej $\tau$ in to kar sledi $S$, $A$ sledi $\eta \Seq \tau \Seq \EOF$, torej $\eta$ in to kar sledi $B$.
\begin{align*}
  \FOLLOW(B) &= \FIRST(\FIRST(\tau) \Seq \FOLLOW(S))\\
  \FOLLOW(A) &= \FIRST(\FIRST(\eta) \Seq \FOLLOW(B))\\
   &= \FIRST(\FIRST(\eta) \Seq \FIRST(\FIRST(\tau) \Seq \FOLLOW(S)))\\
   &= \FIRST(\FIRST(\eta) \Seq \FIRST(\FIRST(\tau) \Seq \FIRST(\EOF)))\\
   &= \FIRST(\FIRST(\eta) \Seq \FIRST(\tau \Seq \EOF))\\
   &= \FIRST(\eta \Seq \tau \Seq \EOF)
\end{align*}
Torej dobimo enako, kot pri izpeljavi.

\Ex Izračunali bomo $\FOLLOW(\Symbol{A})$.
\begin{equation*}
  \begin{aligned}
    \Symbol{S} &\Arrow \Symbol{A} \Seq \underline{\Symbol{C}} \Union \Symbol{B} \Seq \Symbol{f} \\
    \Symbol{A} &\Arrow \Symbol{D} \Union \Symbol{a} \Seq \Symbol{B} \\
    \Symbol{B} &\Arrow \Symbol{b}\\
    \Symbol{C} &\Arrow \Symbol{c} \Seq \Symbol{d}\\
    \Symbol{D} &\Arrow \Symbol{e} \Union \Null
  \end{aligned}
\end{equation*}

$\Symbol{A}$ se pojavi samo v produkciji $\Symbol{S} \Arrow \Symbol{A} \Seq \underline{\Symbol{C}}$, torej:
\begin{align*}
  \FOLLOW(\Symbol{A}) &= \FIRST(\FIRST(\Symbol{C}) \Seq \FOLLOW(\Symbol{S})) \\
             &= \FIRST(\{\Symbol{c}\} \Seq \{\EOF\})\\
             &= \FIRST(\{\Symbol{c} \Seq \EOF\})\\
             &= \FIRST(\Symbol{c} \Seq \EOF) \\
             &= \FIRST(\Symbol{c}) \\
             &= \{\Symbol{c}\}
\end{align*}

\Ex Izračunali bomo $\FOLLOW(\Symbol{B})$.
\begin{equation*}
  \begin{aligned}
    \Symbol{S} &\Arrow \Symbol{A} \Seq \Symbol{C} \Union \Symbol{B} \Seq \underline{\Symbol{f}} \\
    \Symbol{A} &\Arrow \Symbol{D} \Union \Symbol{a} \Seq \Symbol{B} \Seq \underline{\Null} \\
    \Symbol{B} &\Arrow \Symbol{b}\\
    \Symbol{C} &\Arrow \Symbol{c} \Seq \Symbol{d}\\
    \Symbol{D} &\Arrow \Symbol{e} \Union \Null
  \end{aligned}
\end{equation*}
Če je neterminalen simbol na koncu desne strani produkcije mu sledi $\Null$.

$\Symbol{B}$ se pojavi v produkcijah $\Symbol{S} \Arrow \Symbol{B} \Seq \underline{\Symbol{f}}$ in $\Symbol{A} \Arrow \Symbol{a} \Seq \Symbol{B} \Seq \underline{\Null}$, torej:
\begin{align*}
  \FOLLOW(\Symbol{B}) &= \FIRST(\FIRST(\Symbol{f}) \Seq \FOLLOW(\Symbol{S})) \cup \FIRST(\FIRST(\Null) \Seq \FOLLOW(\Symbol{A})) \\
             &= \FIRST(\{\Symbol{f}\} \Seq \{\EOF\}) \cup \FIRST(\{\Null\} \Seq \{\Symbol{c}\}) \\
             &= \FIRST(\{\Symbol{f} \Seq \EOF\}) \cup \FIRST(\{\Null \Seq \Symbol{c}\}) \\
             &= \FIRST(\Symbol{f} \Seq \EOF) \cup \FIRST(\Null \Seq \Symbol{c}) \\
             &= \FIRST(\Symbol{f}) \cup \FIRST(\Symbol{c})\\
             &= \{\Symbol{f}\} \cup \{\Symbol{c}\}\\
             &= \{\Symbol{f}, \Symbol{c}\}
\end{align*}

Lahko bi sklepali tudi direktno (če pripnemo $\Null$ na začetek se vrednost ne spremeni):
\begin{equation*}
  \FIRST(\FIRST(\Null) \Seq \FOLLOW(\Symbol{A})) = \FOLLOW(\Symbol{A})
\end{equation*}

\Ex Podobno lahko izračunamo še za ostale neterminalne simbole:
\begin{align*}
  \FOLLOW(\Symbol{C}) &= \FIRST(\FIRST(\Null) \Seq \FOLLOW(\Symbol{S})) \\
             &= \FIRST(\{\Null\} \Seq \{\EOF\})\\
             &= \FIRST(\{\Null \Seq \EOF\})\\
             &= \FIRST(\EOF) \\
             &= \{\EOF\}
\end{align*}
\begin{align*}
  \FOLLOW(\Symbol{D}) &= \FIRST(\FIRST(\Null) \Seq \FOLLOW(\Symbol{A})) \\
             &= \FIRST(\{\Null\} \Seq \{\Symbol{c}\})\\
             &= \FIRST(\{\Null \Seq \Symbol{c}\})\\
             &= \FIRST(\Symbol{c}) \\
             &= \{\Symbol{c}\}
\end{align*}

Lahko pa uporabimo tudi definicijo na podlagi stavčnih oblik.
\begin{equation*}
  \Symbol{S} \Seq \EOF \begin{aligned}[t]
    &\Derive \Symbol{A} \Seq \Symbol{C} \Seq \EOF \begin{aligned}[t]
      &\Derive \Symbol{D} \Seq \Symbol{C} \Seq \EOF \begin{aligned}[t]
        &\Derive \Symbol{e} \Seq \Symbol{C} \Seq \EOF \Derive \Symbol{e} \Seq \Symbol{c} \Seq \Symbol{d} \Seq \EOF \\
        &\Derive \Null \Seq \Symbol{C} \Seq \EOF \Derive \Symbol{c} \Seq \Symbol{d} \Seq \EOF \\
      \end{aligned}\\
      &\Derive \Symbol{a} \Seq \Symbol{B} \Seq \Symbol{C} \Seq \EOF \Derive \Symbol{a} \Seq \Symbol{b} \Seq \Symbol{C} \Seq \EOF \Derive \Symbol{a} \Seq \Symbol{b} \Seq \Symbol{c} \Seq \Symbol{d} \Seq \EOF
    \end{aligned}\\
    &\Derive \Symbol{B} \Seq \Symbol{f} \Seq \EOF \Derive \Symbol{b} \Seq \Symbol{f} \Seq \EOF
  \end{aligned}
\end{equation*}

Torej vse možne stavčne oblike so:
\begin{multline*}
  \Symbol{S} \Seq \EOF, \Symbol{A} \Seq \Symbol{C} \Seq \EOF, \Symbol{B} \Seq \Symbol{f} \Seq \EOF, \Symbol{D} \Seq \Symbol{C} \Seq \EOF, \Symbol{a} \Seq \Symbol{B} \Seq \Symbol{C} \Seq \EOF, \Symbol{b} \Seq \Symbol{f} \Seq \EOF, \Symbol{e} \Seq \Symbol{C} \Seq \EOF,\\ \Symbol{C} \Seq \EOF, \Symbol{a} \Seq \Symbol{b} \Seq \Symbol{C} \Seq \EOF, \Symbol{e} \Seq \Symbol{c} \Seq \Symbol{d} \Seq \EOF, \Symbol{c} \Seq \Symbol{d} \Seq \EOF, \Symbol{a} \Seq \Symbol{b} \Seq \Symbol{c} \Seq \Symbol{d} \Seq \EOF
\end{multline*}

$\Symbol{C}$ se pojavi v $\Symbol{A} \Seq \Symbol{C} \Seq \underline{\EOF}, \Symbol{D} \Seq \Symbol{C} \Seq \underline{\EOF}, \Symbol{a} \Seq \Symbol{B} \Seq \Symbol{C} \Seq \underline{\EOF}, \Symbol{a} \Seq \Symbol{b} \Seq \Symbol{C} \Seq \underline{\EOF}, \Symbol{e} \Seq \Symbol{C} \Seq \underline{\EOF}, \Symbol{C} \Seq \underline{\EOF}$, torej:
\begin{equation*}
  \FOLLOW(\Symbol{C}) = \FIRST(\EOF) \cup \dots \cup \FIRST(\EOF) = \{\EOF\}
\end{equation*}

$\Symbol{D}$ se pojavi v $\Symbol{D} \Seq \underline{\Symbol{C} \Seq \EOF}$, torej:
\begin{align*}
  \FOLLOW(\Symbol{D}) &= \FIRST(\Symbol{C} \Seq \EOF) \\
             &= \FIRST(\FIRST(\Symbol{C}) \Seq \FIRST(\EOF))\\
             &= \FIRST(\{\Symbol{c}\} \Seq \{\EOF\})\\
             &= \FIRST(\{\Symbol{c} \Seq \EOF\})\\
             &= \FIRST(\Symbol{c} \Seq \EOF) \\
             &= \FIRST(\Symbol{c})\\
             &= \{\Symbol{c}\}
\end{align*}


%Za odločitev, namesto $\FIRST(D)$ in $\FIRST(a)$, uporabimo $\FIRST(\FIRST(D) \Seq \FOLLOW(A))$ in $\FIRST(\FIRST(a) \Seq \FOLLOW(A))$.
%
%\Ex
%  \begin{equation*}
%  \tag{$\Grammar_4$}
%  \label{g:follow}
%  \begin{aligned}
%    S &\Arrow a \Seq A \Seq b \Union c \Seq A \Seq d \\
%    A &\Arrow e \Union \Null
%  \end{aligned}
%\end{equation*}
%
%\begin{align*}
%  \FIRST(a) &= \{a\} \\
%  \FIRST(b) &= \{b\} \\
%  \FIRST(c) &= \{c\} \\
%  \FIRST(d) &= \{d\} \\
%  \FIRST(e) &= \{e\} \\
%  \FIRST(A) &= \FIRST(e) \cup \FIRST(\Null) = \{e\} \cup \{\Null\} = \{\Null, e\} \\
%  \FIRST(a \Seq A \Seq b) &= \FIRST(\FIRST(a) \Seq \FIRST(A \Seq b)) = \FIRST(a) = \{a\} \\
%  \FIRST(c \Seq A \Seq d) &= \FIRST(\FIRST(c) \Seq \FIRST(A \Seq d)) = \FIRST(c) = \{c\}
%\end{align*}
%
%Tukaj se $A$ lahko pojavi v dveh stavčnih oblikah $a \Seq A \Seq b$ in $c \Seq A \Seq d$, torej:
%\begin{align*}
%  \FOLLOW(A) &= \FIRST(b) \cup \FIRST(d)  \\
%             &= \{b\} \cup \{d\} = \{b, d\}
%\end{align*}
%
%\begin{equation*}
%  S \begin{aligned}[t]
%    &\Derive a \Seq A \Seq b \begin{aligned}[t]
%      &\Derive a \Seq e \Seq b\\
%      &\Derive a \Seq \Null \Seq b
%    \end{aligned}\\
%    &\Derive c \Seq A \Seq d
%  \end{aligned}
%\end{equation*}
%
%Zanima nas ali $a \Seq b \in \Language{\text{\ref{g:follow}}}$.
%Začnemo s stavčno obliko $S$, produkcija ${S \Arrow a \Seq A \Seq b \Union c \Seq A \Seq d}$ ima na voljo dve desni strani.
%Če $a \in \FIRST(\FIRST(a \Seq A \Seq b) \Seq \FOLLOW(S))$ potem izberemo $a \Seq A \Seq b$, če je $a \in \FIRST(\FIRST(c \Seq A \Seq d) \Seq \FOLLOW(S))$ potem izberemo $c \Seq A \Seq d$.
%\begin{align*}
%  \FIRST(\FIRST(a \Seq A \Seq b) \Seq \FOLLOW(S)) &= \FIRST(\{a\} \Seq \{\EOF\})\\
%                                                  &= \FIRST(\{a \Seq \EOF\})\\
%                                                  &= \FIRST(a \Seq \EOF)\\
%                                                  &= \FIRST(a)\\
%                                                  &= \{a\}
%\end{align*}
%\begin{align*}
%  \FIRST(\FIRST(c \Seq A \Seq d) \Seq \FOLLOW(S)) &= \FIRST(\{c\} \Seq \{\EOF\})\\
%                                                  &= \FIRST(\{c \Seq \EOF\})\\
%                                                  &= \FIRST(c \Seq \EOF)\\
%                                                  &= \FIRST(c)\\
%                                                  &= \{c\}
%\end{align*}
%Izberemo desno stran $a \Seq A \Seq b$.
%Razpoznali smo terminal $a$.
%
%Sedaj imamo stavčno obliko $a \Seq A \Seq b$, produkcija ${A \Arrow e \Union \Null}$ ima na voljo dve desni strani.
%Če $b \in \FIRST(\FIRST(e) \Seq \FOLLOW(A))$ potem izberemo $e$, če $b \in \FIRST(\FIRST(\Null) \Seq \FOLLOW(A))$ potem izberemo $\Null$.
%\begin{align*}
%  \FIRST(\FIRST(e) \Seq \FOLLOW(A)) &= \FIRST(\{e\} \Seq \{b, d\})\\
%                                                  &= \FIRST(\{a \Seq b, a \Seq d\})\\
%                                                  &= \FIRST(a \Seq b) \cup \FIRST(a \Seq d)\\
%                                                  &= \FIRST(a) \cup \FIRST(a)\\
%                                                  &= \{a\}
%\end{align*}
%\begin{align*}
%  \FIRST(\FIRST(\Null) \Seq \FOLLOW(A)) &= \FIRST(\{\Null\} \Seq \{b, d\})\\
%                                                  &= \FIRST(\{\Null \Seq b, \Null \Seq d\})\\
%                                                  &= \FIRST(\Null \Seq b) \cup \FIRST(\Null \Seq d)\\
%                                                  &= \FIRST(b) \cup \FIRST(d)\\
%                                                  &= \{b, d\}
%\end{align*}
%Izberemo desno stran $\Null$.
%Razpoznali smo terminal $b$.
%
%Sedaj smo prišli do stavka $a \Seq b$.
%Uspelo nam je izpeljati $a \Seq b$, torej ${a \Seq b \in \Language{\text{\ref{g:follow}}}}$.
%
%V primeru, da bi nas zanimalo ali $a \Seq d \in \Language{\text{\ref{g:follow}}}$, bi se pri prejšnjem koraku zgodilo nekaj nenavadnega.
%Izbrana bi bila desna stran $\Null$, ker $d \in \FIRST(\FIRST(\Null) \Seq \FOLLOW(A))$, čeprav $a \Seq d \notin \Language{\text{\ref{g:follow}}}$.
%To je zato, ker $\FOLLOW(A)$ vsebuje simbole iz vseh možnih stavčnih oblik, kontekst se ne upošteva.
%Kljub temu pa bi bil $a \Seq d$ zavrnjen, ker se $d$ ne ujema z $b$ v izpeljanem stavku $a \Seq b$.


%\subsection*{Primeri}

\section{Implementacija}

Za vsako produkcijo $A \Arrow \gamma \Union \dots \Union \eta \in \Productions$ izračunamo:
\begin{gather*}
  \FIRST(\FIRST(\gamma) \Seq \FOLLOW(A))\\
  \dots\\
  \FIRST(\FIRST(\eta) \Seq \FOLLOW(A))
\end{gather*}

Pripravimo funkcijo, kjer $\gamma = X_1 \Seq X_2 \Seq \dots \Seq X_n$ in $\eta = Y_1 \Seq Y_2 \Seq \dots Y_m$:

\begin{algorithm}
  function recognizeA()
    return when lookahead
      $\FIRST(\FIRST(\gamma) \Seq \FOLLOW(A))$ $\rightarrow$ recognizeX$_1$() $\&\&$ recognizeX$_2$() $\&\&\ \dots\ \&\&$ recognizeX$_n$()
      $\dots$
      $\FIRST(\FIRST(\eta) \Seq \FOLLOW(A))$ $\rightarrow$ recognizeY$_1$() $\&\&$ recognizeY$_2$() $\&\&\ \dots\ \&\&$ recognizeY$_m$()
      else $\rightarrow$ false
\end{algorithm}

Za vsako produkcijo $A \Arrow \sigma \in \Productions$ ni potrebno izračunati ničesar, ker imamo na voljo samo eno desno stran in zato ni potrebno izbirati.

Pripravimo funkcijo, kjer $\sigma = Z_1 \Seq Z_2 \Seq \dots \Seq Z_p$:

\begin{algorithm}
  function recognizeA()
    return recognizeZ$_1$() $\&\&$ recognizeZ$_2$() $\&\&\ \dots\ \&\&$ recognizeZ$_p$()
\end{algorithm}

Za vse terminale lahko pripravimo eno samo funkcijo, ki prejme terminal, ki ga želimo razpoznati:
\begin{algorithm}
  function recognizeTerminal($a$)
    $\dots$
\end{algorithm}

\Ex
\begin{equation*}
  \begin{aligned}
    \Symbol{S} &\Arrow \Lookahead{\Symbol{a}, \Symbol{c}, \Symbol{e}} \Symbol{A} \Seq \Symbol{C} \Union \Lookahead{\Symbol{b}} \Symbol{B} \Seq \Symbol{f} \\
    \Symbol{A} &\Arrow \Lookahead{\Symbol{e}, \Symbol{c}} \Symbol{D} \Union \Lookahead{\Symbol{a}} \Symbol{a} \Seq \Symbol{B} \\
    \Symbol{B} &\Arrow \Symbol{b}\\
    \Symbol{C} &\Arrow \Symbol{c} \Seq \Symbol{d}\\
    \Symbol{D} &\Arrow \Lookahead{\Symbol{e}} \Symbol{e} \Union \Lookahead{\Symbol{c}} \Null
  \end{aligned}
\end{equation*}

\begin{align*}
  \FIRST(\FIRST(\Symbol{A} \Seq \Symbol{C}) \Seq \FOLLOW(\Symbol{S})) &= \FIRST(\{\Symbol{a}, \Symbol{c}, \Symbol{e}\} \Seq \{\EOF\})\\
  &= \FIRST(\{\Symbol{a} \Seq \EOF, \Symbol{c} \Seq \EOF, \Symbol{e} \Seq \EOF\})\\
  &= \FIRST(\Symbol{a} \Seq \EOF) \cup \FIRST(\Symbol{c} \Seq \EOF) \cup \FIRST(\Symbol{e} \Seq \EOF)\\
  &= \FIRST(\Symbol{a}) \cup \FIRST(\Symbol{c}) \cup \FIRST(\Symbol{e})\\
  &= \{\Symbol{a}\} \cup \{\Symbol{c}\} \cup \{\Symbol{e}\}\\
  &= \{\Symbol{a}, \Symbol{c}, \Symbol{e}\}
\end{align*}
\begin{align*}
  \FIRST(\FIRST(\Symbol{B} \Seq \Symbol{f}) \Seq \FOLLOW(\Symbol{S})) &= \FIRST(\{\Symbol{b}\} \Seq \{\EOF\})\\
  &= \FIRST(\Symbol{b} \Seq \EOF)\\
  &= \FIRST(\Symbol{b}) \\ 
  &= \{\Symbol{b}\} 
\end{align*}
\begin{align*}
  \FIRST(\FIRST(\Symbol{D}) \Seq \FOLLOW(\Symbol{A})) &= \FIRST(\{\Null, \Symbol{e}\} \Seq \{\Symbol{c}\})\\
  &= \FIRST(\{\Null \Seq \Symbol{c}, \Symbol{e} \Seq \Symbol{c}\})\\
  &= \FIRST(\Null \Seq \Symbol{c}) \cup \FIRST(\Symbol{e} \Seq \Symbol{c})\\
  &= \FIRST(\Symbol{c}) \cup \FIRST(\Symbol{e})\\
  &= \{\Symbol{c}\} \cup \{\Symbol{e}\}\\
  &= \{\Symbol{c}, \Symbol{e}\}
\end{align*}
\begin{align*}
  \FIRST(\FIRST(\Symbol{a} \Seq \Symbol{B}) \Seq \FOLLOW(\Symbol{A})) &= \FIRST(\{\Symbol{a}\} \Seq \{\Symbol{c}\})\\
  &= \FIRST(\{\Symbol{a} \Seq \Symbol{c}\})\\
  &= \FIRST(\Symbol{a} \Seq \Symbol{c})\\ 
  &= \FIRST(\Symbol{a})\\
  &= \{\Symbol{a}\}
\end{align*}
\begin{align*}
  \FIRST(\FIRST(\Symbol{e}) \Seq \FOLLOW(\Symbol{D})) &= \FIRST(\{\Symbol{e}\} \Seq \{\Symbol{c}\})\\
  &= \FIRST(\{\Symbol{e} \Seq \Symbol{c}\})\\
  &= \FIRST(\Symbol{e} \Seq \Symbol{c})\\ 
  &= \FIRST(\Symbol{e})\\
  &= \{\Symbol{e}\}
\end{align*}
\begin{align*}
  \FIRST(\FIRST(\Null) \Seq \FOLLOW(\Symbol{D})) &= \FIRST(\{\Null\} \Seq \{\Symbol{c}\})\\
  &= \FIRST(\{\Null \Seq \Symbol{c}\})\\
  &= \FIRST(\Null \Seq \Symbol{c})\\ 
  &= \FIRST(\Symbol{c})\\
  &= \{\Symbol{c}\}
\end{align*}

Možice za vse desne strani produkcije morajo biti tuje, drugače se ne moremo odločiti:
\begin{align*}
  \FIRST(\FIRST(\Symbol{A} \Seq \Symbol{C}) \Seq \FOLLOW(\Symbol{S})) &\cap \FIRST(\FIRST(\Symbol{B} \Seq \Symbol{f}) \Seq \FOLLOW(\Symbol{S})) = \Empty\\
  \FIRST(\FIRST(\Symbol{D}) \Seq \FOLLOW(\Symbol{A})) &\cap \FIRST(\FIRST(\Symbol{a} \Seq \Symbol{B}) \Seq \FOLLOW(\Symbol{A})) = \Empty\\
  \FIRST(\FIRST(\Symbol{e}) \Seq \FOLLOW(\Symbol{D})) &\cap \FIRST(\FIRST(\Null) \Seq \FOLLOW(\Symbol{D})) = \Empty
\end{align*}
\begin{align*}
  \{\Symbol{a}, \Symbol{c}, \Symbol{e}\} &\cap \{\Symbol{b}\} = \Empty \OK\\
  \{\Symbol{e}, \Symbol{c}\} &\cap \{\Symbol{a}\} = \Empty \OK\\
  \{\Symbol{e}\} &\cap \{\Symbol{c}\} = \Empty \OK
\end{align*}

\begin{algorithm}
  function recognizeS()
    return when lookahead
      $\Symbol{a}, \Symbol{c}, \Symbol{e}$ $\rightarrow$ recognizeA() $\&\&$ recognizeC()
      $\Symbol{b}$ $\rightarrow$ recognizeB() $\&\&$ recognizeTerminal($\Symbol{f}$)
      else $\rightarrow$ false

  function recognizeA()
    return when lookahead
      $\Symbol{e}, \Symbol{c}$ $\rightarrow$ recognizeD()
      $\Symbol{a}$ $\rightarrow$ recognizeTerminal($\Symbol{a}$) $\&\&$ recognizeB()
      else $\rightarrow$ false

  function recognizeB()
    return recognizeTerminal($\Symbol{b}$)

  function recognizeC()
    return recognizeTerminal($\Symbol{c}$) $\&\&$ recognizeTerminal($\Symbol{d}$)

  function recognizeD()
    return when lookahead
      $\Symbol{e}$ $\rightarrow$ recognizeTerminal($\Symbol{e}$)
      $\Symbol{c}$ $\rightarrow$ true
      else $\rightarrow$ false
\end{algorithm}

\newpage
Primer kode za jezike, ki so bolj podobni C:
\begin{algorithm}
  function recognizeS()
    switch lookahead
      case $\Symbol{a}$:
      case $\Symbol{c}$:
      case $\Symbol{e}$:
        return recognizeA() $\&\&$ recognizeC()
      case $\Symbol{b}$:
        return recognizeB() $\&\&$ recognizeTerminal($\Symbol{f}$)
      default:
        return false

  function recognizeA()
     switch lookahead
      case $\Symbol{e}$:
      case $\Symbol{c}$:
        return recognizeD()
      case $\Symbol{a}$:
        return recognizeTerminal($\Symbol{a}$) $\&\&$ recognizeB()
      default:
        return false

  function recognizeB()
    return recognizeTerminal($\Symbol{b}$)

  function recognizeC()
    return recognizeTerminal($\Symbol{c}$) $\&\&$ recognizeTerminal($\Symbol{d}$)

  function recognizeD()
    switch lookahead
      case $\Symbol{e}$:
        return recognizeTerminal($\Symbol{e}$)
      case $\Symbol{c}$:
        return true
      default:
        return false
\end{algorithm}

\printbibliography
\end{document}
